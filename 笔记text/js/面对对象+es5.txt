                                                                 （面向对象的特点）
封装性
继承性
多态性
                                                         （面向过程和面向对象的对比）
面向过程
优点：性能比面向对象高 适合跟硬件联系很紧密的东西 例如单片机 就采用的面向过程编程
缺点：没有面向对象 易维护 易复用 易扩展
面向对象
优点：易维护 易复用 易扩展 由于面向对象有封装 继承 多态性的特点 可以设计出低耦合的系统使系统更加灵活 更加易于维护
缺点：性能比面向过程低
                                                              （面对对象的思维特点）
1.抽取（抽象） 对象公共的属性和行为组织（封装）成一个类（模板）
2.对类进行实例化 获取类的对象
面向对象编程我们考虑是有那些对象 按照面向对象的思维特点不断的创建对象 使用对象 指挥对象做事情
对象是由属性和方法组成的
属性：实物的特征 在对象中用属性来表示
方法：实物的行为在对象中用方法来表示
类class
在es6 中新增加了类的概念 可以使用class关键字声明一个类 之后这个类来实例化对象
类抽象了对象的公共部分 它泛指某一大类class
对象特指某一个 通过类实例化一个具体的对象
                                                                           （创建类）
语法：
class name{
//class body
}
创建实例
var xx = new name（）；
注意:类必须使用new实例化对象 
                                                              （类 constructor 构造函数）
constructor（）方法是类的构造函数（默认方法）用于传递参数 返回实例化对象 通过new 命令生成对象实例化时 自动调用该方法 如果没有显示定义 类内部会自动给我们创建一个constructor
                                                                               （继承）
                                                                             （exends ）
语法：
class Father {
//父类
}
class on Son exends Father{
//子类继承父级
}
                                                                         （super 关键字）
super 关键字用于访问和调用对象父类上的函数 可调用父类的构造函数 也可以调用父类的普通函数
                                                                          （类和对象注意点）
三个注意点：
1.在ES6 中类没有变量提升  所以必须先定义类 才能通过类实例化对象
2.类里面的共有的属性和方法一定要加this使用
3.类里面的指向问题
4.constructor 里面的this指向实例对象 方法里面的this指向这个方法的调用者
                                                                         （创建对象的三种方式）
1.对象字面量
2.new Object（）
3.自定义构造函数
                                                                                  （构造函数）
构造函数是一种特殊的函数 主要用来初始化对象  即为对象成员变量赋初始化 它总跟new 一起使用 我们可以把对象中一些公共的属性和方法抽取出来 然后封装到这个函数里面
在js中 使用构造函数时注意一下两点
1.构造函数 用于创建某一类对象  其首字母要大写
2.构造函数要和new一起使用才有意义

静态成员：在构造函数本上添加的成员称为静态成员 只能由构造函数本身来访问
实例成员：在构造函数内部创建的对象成员称为实例成员  只能由实例化的对象来访问
                                                                              （构造函数的问题）
构造函数方法很好用 但是存在浪费内存的问题
                                                                     （构造函数原型 prototype）
构造函数通过原型分配的函数时所有对象所共享的
我们可以把那些不变的方法直接定义在 prototype 对象上 这样所有对象的实例就可以共享这些方法
问答？
1.原型是什么?
一个对象 我们称为prototype为原型对象
2.原型的作用是什么？
共享方法
一般情况下 我们公共属相定义到构造函数里面 公共的方法我们放到 原型对象身上
                                                                             (对象原型_proto_)
对象都会有一个属性 _proto_ 指向构造函数的prototype 原型对象 之所以我们对象可以使用构造函数 prototype 原型对象的属性方法  就是因为对象有_proto_原型的存在
                                                                                  （ 原型链）
//方法的查询规则: 首先先看ldh 对象身上是否有sing 方法 如果有就执行这个对象上的sing
 // 如果没有sing这个方法  因为有_proto_的存在 就去构造函数原型对象prototype身上去查找sing这个方法
_proto_ 对象原型和原型对象 prototype 是等价的
                                                                       （constructor构造函数）
对象原型_proto_ 和构造函数prototype 原型对象 里面都有一个属性constructor 属性constructor我们称为构造函数 因为它指向回调函数本身
constructor主要用于记录该对象引用与哪个构造函数 它可以让原型对象重新指向原来的构造函数
                                                                    （JavaScript的成员查找机制）（规则）
1.当访问一个对象的属性 （包括方法）时首选查找这个对象自身有没有该属性
2.如果没有就查找它的原型（也就是__pro__指向的prototype原型对象）
3.如果还没有就查找原型对象的原型（Object的原型对象）
4.以此类推一直找到Object为止（null）
5.__pro__ 对象原型的意义就在于为对象成员查找机制提供一个方向 或者说一条路线
                                                                                    （继承）
ES06之前并没有给我们提供extends 继承 我们可以通过构造函数+原型对象模拟实现继承 被称为组个继承
2.1 call（）
调用这个函数 并且修改函数运行的this指向
fun call （thisArg,arg1,arg2）
thisAr：当前调用函数this的指向对象
arg1 arg2 传递的其他参数
                                                                           （ES5中的新增方法）
3.2数组方法
迭代（遍历）方法：forEach(),map(),filter(),some(),every();
                                                                                   forEach()
array.forEach(function(currentValue,index,arr))
currentValue:数组当前项的值
index：数组当前项的索引号
arr：数组对象本身
                                                                                    filter()
array.filter(function(currentValue,index,arr))
filter()方法创建一个新的数组 新数组中的元素是通过检查指定数组中符合条件的所有元素 主要用于筛选数组
注意它直接返回一个新数组
currentValue：数值当前的值
index：数组当前项的索引号
arr :数组本身
                                                                          （字符串的方法）
trim()方法会从一个字符串 的两端删除空白字符
str.trum()
trim()方法并不影响原字符串本身1  它返回的是一个新的字符串
                                                                                 ( 对象方法）
object.defineproperty(obj,prop,descriptor)
obj  必须 目标对象
prop  必须 需定义或修改的属性名字
descriptor 必须 目标属性所拥有的特性
descriptor第三个参数说明 以对象形式{}书写
value：设置属性的值 默认为 undefined
writable：值是否可以重写 true false 默认 false
enumerable：目标属性是否可以被枚举  truefalse 默认为 false
configurable  目标属性是否可以被删除或是否可以在再次修改true false 默认 false
  <script>
                                                                            //函数调用方式
        //1.普通函数、
        function fn() {
            console.log('人生的巅峰');
        }
        // fn(); fn.call();
        //2.对象的方法
        var o = {
            sayHi: function () {
                console.log('人生的巅峰');
            }
        }
        o.sayHi();
        //3.构造函数
        function Star() {};
        new Star();
        //4.绑定事件函数
        btn.onclick = function () {}; // 点击了按钮就可以调用这个函数
        //5.定时器函数
        setInterval(function () {}, 1000); //这个函数 是定时器自动1秒钟 调用一次
        //6.立即执行函数
        (function () {
            console.log('人生的巅峰'); //立即执行函数时自动调用
        })()
    </script>
                                          （函数内this的指向）
这些this的指向 是当我们调用函数的时候确定的 调用方式的不同决定了this 的指向不同一般指向我们的调用者
调用方式                                   this指向
普通函数调用                             window
构造函数调用                              实例对象 原型对象 里面的方法也指向实例对象
对象方法调用                              该方法所属对象
事件绑定方法                              绑定事件对象
定时器函数                                   window
立即执行函数                                window
                                                                             （改变函数内部this指向）
javaScript 为我们专门提供了一些函数方法来 帮我们更优雅的处理函数 内部this 指向问题 常用的有bind()call() apply()
                                                                                      1.call(）方法
call()方法调用一个对象  简单理解为调用函数的方式  但是它可以改变函数的this指向
fun.call(thisArg,arg1,arg2,.....)
                                                                                      2.apply()方法
apply（） 方法 调用一个函数 简单理解为调用函数的方式 但是它可以改变函数的this指向
fun.apply (thisArg,[arrsArray])
thisArg:在fun函数运行时指定的this值
argsArray 传递的值 必须包含在数组里面
返回值就是函数的返回值 因为它就是调用函数
                                                                                       3.bind()方法
bind()方法不会调用函数 但是能改变函数内部this指向
fun.bind(thisArg,arg1,arg2,...)
thisArg:在fun函数运行时指定的this值
arg1 arg2 传递的其他参数
返回由指定的this 值和初始化参数改造的原函数拷贝
                                                                                （call apply bind 总结）
相同点：
都可以改变函数内部的this指向
区别点：
1.call 和 apply 会调用函数  并且改变函数内部this指向
2.call和apply 传递的参数不一样 call传递参数 aru1，aru2 ..形式apply 必须数组形式[arg]
3.bind 不会调用数组 可以改变函数内部this指向
主要应用场景：
1.call 经常做继承
2.apply 经常跟数组有关心 比如借助于数学对象实现数组最大值最小值
3.bind 不用调用数组 但是还想改变this指向 比如改变定时器内部的this指向
                                                                                             （严格模式）
1.变量规定 
（1）在正常模式中  如果一个变量没有声明就赋值 默认是全局变量 严格模式禁止这种用法  变量都必须先用 var 命令声明 然后再使用
（2）严禁删除已经声明变量 例如 delete x ；语法是错误的
2. 严格模式下this指向问题
（1）以前在全局作用域函数中的this指向 window对象
                                                                                          (高阶函数)
高阶函数是对其他函数进行操作的函数 他接收作为参数或将函数作为返回值输出
函数也是一个数据类型 同样可以作为参数 传递给另外一个参数使用  最经典的就是作为回调函数
                                                                                          （闭包）
闭包（closure）  指有权访问另一个函数作用域中的变量的函数       JavaScript 高级程序设计
简单理解就是  一个作用域可以访问另外一个函数内部的局部变量
闭包是什么：
闭包是一个函数 （一个作用域可以访问另外一个函数的局部变量）
闭包的作用：
延伸变量的作用范围
                                                                                                （递归）
如果一个函数在内部可以调用其本身  那么这个函数就是递归函数、
简单理解 函数内部自己调用自己 这个函数就是递归函数
递归函数 的作用和循环效果一样
由于递归很容易发生 栈溢出 错误  所以必须要加 退出条件 return
                                                                                        （浅拷贝和深拷贝）
1.浅拷贝只是拷贝一层 更深层次对象级别的只拷贝引用
2.深拷贝拷贝多层每一级别的数据都会拷贝
3.Object.assign(target,....sources) es6 新增方法可以浅拷贝
                                                                                      （正则表达式概述）
什么是正则表达式
正则表达式 是用于匹配字符串中字符组合的模式  在JavaScript中正则表达式也是对象 
正则表达式通常被用来检索 替换那些符合某个模式（规则）的文本例如验证表单 用户名表单只能输入英文字母 数字或者下划线 昵称输入框中可以输入中文 此外 正则表达式还常用于过滤页面内容中的一些敏感词（替换）或从字符串中获取我们想要得特定部分等
其他语言也会使用正则表达式 本阶段我们主要利用JavaScript正则表达式完成表单验证
1.2正则表达式的特点
1.灵活性 逻辑性和功能非常强
2.可以迅速地用极简的方式达到字符串的复杂控制
3.对于刚接触的人来说 比较晦涩难懂 比如^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
4.实际开发中 一般都是直接复制写好的正则表达式 但是要求会使用正则表达式并且根据实际情况修改正则表达式 
比如同户名 ：/^[a-z0-9_-]{3,16}&/
                                                                                      (创建正则表达式)
在JavaScript中可以通过两种方式创建一个正则表达式
1.同过调用 RegExp 对象的构造函数创建
 var regexp = new RegExp(/123/);
2.利用字面量创建 正则表达式
 var rg = /123/;
                                                                                （测试正则表达式test）
test()正则对象的方法 用于检测字符串是否符合规则 该对象会返回true或false 其参数是测试字符串
regexObj.text(str)
1.regexObj 是写的正则表达式
2.str我们要测试的文本
3.就是检测str 文本是否符合我们写的正则表达式规范
                                                                               （正则表达式的组成）
3.1正则表达式的组成
一个正则表达式可以由简单的字符构成 比如/abc/ 也可以是简单和特殊字符的组合 比如/ab*c/ 其中特殊字符也称为元字符在正则表达式中是具有特殊意义的专用符号 如 ^ , $ , + 等
                                                                                        （边界符）
正则表达式中的边界符 用来提示字符所处的位置 主要有两个字符
边界符                               说明
^                                       表示匹配行首的文本（以谁开始）
$                                        表示匹配行尾的文本（以谁结束）
字符类
[] 表示有一系列字符可提供选择  只要匹配其中一个就可以了
[-] 方括号 内部 范围符-